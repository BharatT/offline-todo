<h1>Building a simple cross browser offline todo list with IndexedDB (and WebSQL)</h1>

<h2>What's going on here?</h2>

<p>Hi I'm <a href="https://twitter.com/andrewsmatt">Matt</a>, I work for FT Labs <a href="http://labs.ft.com/jobs">(and you should too)</a>.  I'm running a workshop on <a href="http://smashingconf.com/freiburg-2014/workshops/matthew-andrews">building offline web applications in Freiburg, Germany in September 2014</a> and again in London in November 2014 - and for the dual purposes of promoting <a href="http://offlinefirst.org/">offline-first</a> web applications and shamelessly trying to encourage ticket sales I thought I'd share part of one of the exercises that I'll be guiding people through during those workshops.  Much credit due to <a href="https://twitter.com/Paul_Kinlan">Paul Kinlan</a> for the work I've <a href="http://www.html5rocks.com/en/tutorials/indexeddb/todo/">plagiarised from him</a>.</p>

<h2>Introduction</h2>

<p>We're going to make a simple <a href="https://matthew-andrews.github.io/offline-todo/">todo application</a> with HTML5 technologies that <strong>stores its data offline</strong>.  You will be able to <strong>add</strong> and <strong>delete</strong> todos, and it should work on the <strong>1st</strong> and <strong>2nd</strong> most recent versions of all major desktop and mobile browsers.  The complete project is <a href="https://github.com/matthew-andrews/offline-todo">ready for forking on GitHub</a>.</p>

<h2>What technologies to use</h2>

<p>In an ideal world there would be just one client database technology.  Unfortunately, there are two:-</p>

<ul>
  <li><strong>IndexedDB</strong> - the community agreed standard for client side storage, and <a href="http://caniuse.com/indexeddb">the only option available on Firefox and Internet Explorer</a></li>
  <li><strong>WebSQL</strong> - the now deprecated predecessor to WebSQL, and <a href="http://caniuse.com/sql-storage">the only option available on current versions of iOS</a> (although iOS8 will finally give us IndexedDB)</li>
</ul>

<p>(Veterans in the offline-first world will now probably be thinking: but we could just use <a href="http://caniuse.com/namevalue-storage">localStorage</a>, which has the benefits of a <strong>much simpler API</strong> and we won't need to worry about the complexity of using both IndexedDB and WebSQL.  Whilst that is technically true, there are a <a href="https://hacks.mozilla.org/2012/03/there-is-no-simple-solution-for-local-storage/">number of problems with localStorage</a> - most importantly the amount of storage space available for localStorage is significantly less than IndexedDB/WebSQL).</p>

<p>Luckily, although we're going to need <strong>to use both</strong> we only need to think about <strong>IndexedDB</strong>.  To be able to support WebSQL we're going to use an <a href="https://github.com/axemclion/IndexedDBShim">IndexedDB polyfill</a>.  This will keep our code clean and easy to maintain and, in the future, when all the browsers we care about are able to support IndexedDB natively, we can simply delete the polyfill.</p>

<p><strong>If you're starting a new project and are currently deciding whether to use IndexedDB or WebSQL, I strongly advocate using IndexedDB and the polyfill.  In my opinion, there is no reason to write any new code that integrates with WebSQL directly.</strong></p>

<p>I've described all the steps using <strong>Google Chrome</strong> (and its developer tools) because currently it's the most popular browser among developers - but there's no reason why you couldn't develop this application with any other modern browser.</p>

<h2>Step 1 - Scaffolding the application and opening a database</h2>

<p>Start by creating the following files:-</p>
<ul>
  <li><strong>/index.html</strong></li>
  <li><strong>/application.js</strong></li>
  <li><strong>/indexeddb.shim.min.js</strong></li>
  <li><strong>/styles.css</strong></li>
</ul>

<h3>/index.html</h3>

<script src="https://gist.github.com/matthew-andrews/85c34d98443c1e041e5b.js"></script>

<p>There should be nothing surprising here - it's a standard HTML5 web page, with an input field to add your items to do and empty unordered list that will be filled with those items.</p>

<h3>/indexeddb.shim.min.js</h3>

Download the <a href="https://raw.githubusercontent.com/matthew-andrews/offline-todo/gh-pages/indexeddb.shim.min.js">contents of the minified IndexedDB polyfill</a> and put it in this file.

<h3>/styles.css</h3>

<script src="https://gist.github.com/matthew-andrews/34b26612f97ac4938bcf.js"></script>

<p>Again this should be quite familiar - these are just some simple styles to make the todo list look tidy.  You can choose not to have any styles at all, or create your own.

<h3>/application.js</h3>

<script src="https://gist.github.com/matthew-andrews/a0ed7489119f363fd344.js"></script>

<p>All this code does is <strong>attempt to create a database</strong> and then shows the user an old fashioned alert if it was successful.  Every IndexedDB database needs a name (in this case I've named it <strong>todos</strong>) and it also needs a version number, which I've set to 1.</p>

<p>To check that it's working, open the application in <strong>Google Chrome</strong> and open up <strong>Developer Tools</strong> (located under <strong>View</strong> &raquo; <strong>Developer</strong> &raquo; <strong>Developer Tools</strong>) and click on the <strong>Resources</strong> tab.</p>

<p><img src="./images/step1-dev-tools.png" /></p>

<p>By clicking on the triangle next to <strong>IndexedDB</strong>, you should see that a database called <strong>todos</strong> has been created.</p>

<h2>Step 2 - Creating the object store</h2>

<p>Like many database formats that you might be familiar with, within a single IndexedDB database you can create many 'tables'.  Those tables are called <strong>objectStores</strong>.  In this step we're going to create an object store called <strong>todo</strong>, to do this we simply add an event listener on the database's <strong>upgradeneeded</strong> event.</p>

<p>For our offline todo app we're going to the data format as simple as possible and store javascript objects with two properties:-</p>

<ul>
  <li><strong>timeStamp</strong> - a timestamp that will also act as our key</li>
  <li><strong>text</strong> - the text the user has entered</li>
</ul>

<p>For example:</p>

<pre>{ timeStamp: 1407594483201, text: 'Wash the dishes' }</pre>

<h3>/application.js now looks like this (the new lines are between 15 and 20)</h3>

<script src="https://gist.github.com/matthew-andrews/32218027f06bcfba9d12.js"></script>

<p>This will create an object store keyed by <strong>timeStamp</strong> called <strong>todo</strong>.</p>

<p>Having updated <strong>application.js</strong>, if you open the web app again you'll notice that not a lot happens (try adding a <strong>console.log</strong> in the <strong>onupgradeneeded</strong> callback to be sure). The problem is we haven't increased the version number so the browser <em>doesn't know it needs to run the upgrade callback</em>.</p>

<h3>How to solve this</h3>

<p>Whenever you need to add or remove object stores you will need to <strong>increment the version number</strong> - otherwise the structure of the data will be different to what your code expects and you risk breaking your application in ways that can be very difficult to fix.</p>

<p>There is another way to fix this that we can use because this application doesn't have any real users yet - and that is to delete the database.  Copy this line of code into the <strong>Console</strong> (last tab in Developer Tools), press enter and then refresh the page:-</p>

<pre>indexedDB.deleteDatabase('todos');</pre>

<p>After refreshing, the <strong>Resources</strong> pane of Developer Tools should have changed and should now show the object store that we added:-</p>

<img src="./images/step2-dev-tools.png" />

<h2>Step 3 - Adding todos</h2>

<p>The next step is to enable <strong>adding todos</strong>.</p>

<h3>/application.js - note: I've ommitted the database opening code (it's represented by '[...]' instead)</h3>

<script src="https://gist.github.com/matthew-andrews/f8580b6206f8cd646bbd.js"></script>

<p>We've added two new bits of code here:-</p>

<ul>
  <li>An <strong>event listener</strong> that will react to every <strong>submit</strong> event, <strong>prevent that event's default action</strong> (which would otherwise refresh the page), call <strong>databaseTodosAdd</strong> with the value of the <strong>input</strong> element and (if the todo is successfully added) set the value of the <strong>input</strong> element to be empty.
  <li>A function called <strong>databaseTodosAdd</strong> that will store the <strong>todo</strong> in the local database along with a timestamp and then run a <strong>callback</strong></li>
</ul>

<p>To test this is working, open up the web app in Chrome again.  Type some words into the <strong>input</strong> element and press <strong>enter</strong>.  Repeat this a few times and then open up Developer Tools on the Resources tab again.  You should see the items that you typed in now appear in the <strong>todo object store</strong>.</p>

<img src="./images/step3-dev-tools.png" />

<h2>Step 4 - Retrieving todos</h2>

<p>Now that we've got some data stored, the next step is to work out how to retrieve that data.</p>

<h3>/application.js - note: [...] represents the code we have already implemented in steps 1, 2 and 3</h3>

<script src="https://gist.github.com/matthew-andrews/fc0c2db625ba74fcd84c.js"></script>

<p>After the database has been initialised, what this will do is <strong>retrieve all of the todos</strong> and output them to the Developer Tools console.</p>

<p>Notice how the <strong>onsuccess</strong> callback is called after each todo is retrieved from the object store.  To keep things simple we put each result into an array called <strong>data</strong> and when we run out of results (which happens when we've retrieved all of the todos) we called the <strong>callback</strong> with that array.  This approach is simple but other approaches might be more efficient.</a>

<p>If you re-open the application in Chrome again, Developer Tools console should look a bit like this:-</p>

<img src="./images/step4-dev-tools.png" />

<h2>Step 5 - Displaying todos</h2>

<p>The next step after retrieving the todos is <strong>displaying</strong> them.</p>

<h3>/application.js</h3>

<script src="https://gist.github.com/matthew-andrews/6ac3fd8b072e83e9cfb3.js"></script>

<p>All we've added is a couple of very simple functions that render the todos:-</p>
<ul>
  <li><strong>todoToHtml</strong> - takes a todo object (the simple javascript object we defined earlier).</li>
  <li><strong>renderAllTodos</strong> - takes an <strong>array of todos objects</strong>, converts them to an <strong>HTML string</strong> and sets the <strong>unordered list's innerHTML</strong> to it.</li>
</ul>

<p>Finally we're at a point where we can actually see what our application is doing without having to look through Developer Tools!  Open it up in Chrome and you should see something like this:-</p>

<img src="./images/step5-app.png" />

<p>But we're not done yet.  Because the application is only displaying todos when it starts, if we add any new ones - they don't appear unless we refesh the page.

<h2>Step 6 - Displaying <em>new</em> todos</h2>

<p>We can now fix this with a single line of code.</p>

<h3>/application.js</h3>

<script src="https://gist.github.com/matthew-andrews/4da8655d41441ba0813b.js"></script>

<p>Although this is very simple, it's not very efficient.  Every time we add a todo the code will need to retreieve <strong>every single</strong> todo from the database again and <strong>render them all on screen</strong>.  <em>Think about how this could be made more efficient.</em></p>

<h2>Step 7 - Deleting todos</h2>

<p>To keep things as simple as possible we will let users delete todos by clicking on them (for real applications we would probably want a dedicated delete button or to show a dialog so that todos don't get accidentally deleted, but this will be fine for our little prototype).</p>

<p>To achieve this we will be a little bit hacky and give all the todos an <strong>id</strong> that is set to their <strong>timeStamp</strong>.  This will allow the click event listener, which we will add to the <strong>document body</strong>, to identify when we click on a todo (as opposed to anywhere else on the page).

<h3>/application.js</h3>

<script src="https://gist.github.com/matthew-andrews/a7c7978cddff7bf2bb1d.js"></script>

<p>We've made the following enhancements:-</p>

<ul>
  <li>Added a new event handler (<strong>onClick</strong>) that listens to click events, checks to see if the <strong>target element</strong> has an <strong>id</strong> attribute, if it does convert that back into an integer with <strong>parseInt</strong>, calls <strong>databaseTodosDelete</strong> with that value, and - if the todo is successfully deleted - it will re-render the todo list using the same approach we took in <strong>Step 6</strong>.</li>
  <li>Enhanced the <strong>todoToHtml</strong> function so that every <strong>todo</strong> is output with an <strong>id</strong> attribute, set to its <strong>timeStamp</strong>.</li>
  <li>Added a new function, <strong>databaseTodosDelete</strong>, which take that <strong>timeStamp</strong> and a <strong>callback</strong>, deletes the <strong>todo</strong> then runs the <strong>callback.</strong></li>
</ul>

<p>The todo app is basically feature complete - you can <strong>add and delete todos</strong> and it works any browser that supports <strong>WebSQL or IndexedDB</strong> (although it could be a lot more efficient).</p>

<h2>But have we actually built an offline-first todo list app?</h2>

<p>Almost, but not quite.  Although we can now store all the todo data offline, if you switch your device's internet connection off and try loading the application, it won't open.  To fix this we need to use either the HTML5 AppCache or ServiceWorker</p>

<p>Also, by storing all the data on the user's device we're not really taking full advantage of the full power of the web.  Wouldn't it be better if the application could synchronise with a server so that you could manage your todos on any of your devices, whether the device was online or not?</p>
